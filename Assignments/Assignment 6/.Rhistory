lambda <- lambdaVector[i]
opt <- solnp(pars = x0, fun = objective, eqfun = eqn1, eqB = eqB, LB = LB, UB = UB)
pars <- opt$pars
if (i == 1) {
parMatrix <- rbind(pars)
} else {
parMatrix <- rbind(parMatrix, pars)
}
}
library("Rsolnp")
lambdaVector <- seq(0, 1, length=10000)
for (i in 1:length(lambdaVector)) {
lambda <- lambdaVector[i]
opt <- solnp(pars = x0, fun = objective, eqfun = eqn1, eqB = eqB, LB = LB, UB = UB)
pars <- opt$pars
if (i == 1) {
parMatrix <- rbind(pars)
} else {
parMatrix <- rbind(parMatrix, pars)
}
}
lambdaVector <- seq(0, 1, length=20)
for (i in 1:length(lambdaVector)) {
lambda <- lambdaVector[i]
opt <- solnp(pars = x0, fun = objective, eqfun = eqn1, eqB = eqB, LB = LB, UB = UB)
pars <- opt$pars
if (i == 1) {
parMatrix <- rbind(pars)
} else {
parMatrix <- rbind(parMatrix, pars)
}
}
# Plot the mean-variance frontier
for (i in 1:dim(parMatrix)[1]) {
sigma <- rbind(parMatrix[i,]) %*% cov(indicesReturns) %*% cbind(parMatrix[i,])
ret <- t(indicesAlphas) %*% cbind(parMatrix[i,]) +
(t(indicesBetas) %*% cbind(parMatrix[i,])) * mean(exp(gdpIndexReturns))
if (i == 1) {
sigmaRets <- cbind(sigma, ret)
} else {
sigmaRets <- rbind(sigmaRets, cbind(sigma, ret))
}
}
plot(sigmaRets, type="b", col="red", main="Mean-variance frontier of the stock indices",
xlab=expression(sigma), ylab=expression(bar(r)))
# Add individual indices
for (i in 1: dim(indicesReturns)[2])  {
indexSigma <- var(indicesReturns[,i])
indexReturn <- mean(exp(indicesReturns[,i]))
if (i == 1) {
indicesSigmaRets <- cbind(indexSigma, indexReturn)
} else {
indicesSigmaRets <- rbind(indicesSigmaRets, cbind(indexSigma, indexReturn))
}
par(new=T)
plot(indicesSigmaRets[i,], pch=6, axes=F)
}
parMatrix
dim(parMatrix)
sum(parMatrix[1,])
sigmaRets
indicesAlphas
indicesBetas
logTotalReturns <- cbind(logTotalVerdiReturns, logMedStocksReturns)
library("quantmod")
### NOW COMPARE ALL MED STOCKS AGAINST EACH OTHER
dates <- cbind("2015-06-01", "2016-02-24")
# BIONOR
BIONOR.OL <- getSymbols("BIONOR.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# BIOTEC
BIOTEC.OL <- getSymbols("BIOTEC.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# COV
COV.OL <- getSymbols("COV.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# HBC
HBC.OL <- getSymbols("HBC.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# MEDI
MEDI.OL <- getSymbols("MEDI.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# NAVA
NAVA.OL <- getSymbols("NAVA.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# PCIB
PCIB.OL <- getSymbols("PCIB.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# PHO
PHO.OL <- getSymbols("PHO.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# SENDEX
SENDEX.OL <- getSymbols("SENDEX.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# SER
SER.OL <- getSymbols("SER.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# VISTIN
VISTIN.OL <- getSymbols("VISTIN.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# Weifa
WEIFA.OL <- getSymbols("WEIFA.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
# Nordic Nanovector
NANO.OL <- getSymbols("NANO.OL", src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
ylim <- c(30, 300)
plot((BIOTEC.OL[,4]/as.numeric(BIOTEC.OL[,4][1]))*100, type="l",
main="Relativ performance - BIOTEC (black), HBC (green), MEDI (red), \nNANO (blue), PHO (cyan), VISTIN (purple), WEIFA (orange)",
ylim=ylim)
par(new=T)
plot((HBC.OL[,4]/as.numeric(HBC.OL[,4][1]))*100, type="l", col="green",
axes=FALSE, xaxt="n", yaxt="n", ylim=ylim, main="")
par(new=T)
plot((MEDI.OL[,4]/as.numeric(MEDI.OL[,4][1]))*100, type="l", col="red",
axes=FALSE, xaxt="n", yaxt="n", ylim=ylim, main="")
par(new=T)
plot((NANO.OL[,4]/as.numeric(NANO.OL[,4][1]))*100, type="l", col="blue",
axes=FALSE, xaxt="n", yaxt="n", ylim=ylim, main="")
par(new=T)
plot((PHO.OL[,4]/as.numeric(PHO.OL[,4][1]))*100, type="l", col="cyan",
axes=FALSE, xaxt="n", yaxt="n", ylim=ylim, main="")
par(new=T)
plot((VISTIN.OL[,4]/as.numeric(VISTIN.OL[,4][1]))*100, type="l", col="purple",
axes=FALSE, xaxt="n", yaxt="n", ylim=ylim, main="")
par(new=T)
plot((WEIFA.OL[,4]/as.numeric(WEIFA.OL[,4][1]))*100, type="l", col="orange",
axes=FALSE, xaxt="n", yaxt="n", ylim=ylim, main="")
### CANDLE CHARTS for "Aktuelle Selskaper"
png(file = paste(getwd(), "/candlecharts/nano.png", sep=""))
candleChart(NANO.OL,multi.col=TRUE,theme='white')
addBBands(n = 20, sd = 2, ma = "SMA", draw = 'bands', on = -1)
addSMA(n = 10, on = 1, with.col = Cl, overlay = TRUE, col = "blue")
dev.off()
png(file = paste(getwd(), "/candlecharts/weifa.png", sep=""))
candleChart(WEIFA.OL,multi.col=TRUE,theme='white')
addBBands(n = 20, sd = 2, ma = "SMA", draw = 'bands', on = -1)
addSMA(n = 10, on = 1, with.col = Cl, overlay = TRUE, col = "blue")
dev.off()
png(file = paste(getwd(), "/candlecharts/medistim.png", sep=""))
candleChart(MEDI.OL,multi.col=TRUE,theme='white')
addBBands(n = 20, sd = 2, ma = "SMA", draw = 'bands', on = -1)
addSMA(n = 10, on = 1, with.col = Cl, overlay = TRUE, col = "blue")
dev.off()
### CANDLE CHART for Novo Nordisk
novo_dates <- cbind("2014-01-01", "2016-02-24")
NVO <- getSymbols("NVO", src="yahoo", auto.assign=FALSE, from=novo_dates[1], to=novo_dates[2])
png(file = paste(getwd(), "/candlecharts/novo.png", sep=""))
candleChart(NVO,multi.col=TRUE,theme='white')
addBBands(n = 20, sd = 2, ma = "SMA", draw = 'bands', on = -1)
addSMA(n = 10, on = 1, with.col = Cl, overlay = TRUE, col = "blue")
dev.off()
### LOG RETURN Rolling Correlation
library(corrplot)
medStockTickerList <- c("NANO.OL", "WEIFA.OL", "MEDI.OL")
logMedStocksReturns <- (log(cbind(as.numeric(NANO.OL[,4]), as.numeric(WEIFA.OL[,4]),
as.numeric(MEDI.OL[,4]))))
logMedStocksReturns <- logMedStocksReturns[2:dim(logMedStocksReturns)[1],]-
logMedStocksReturns[1:(dim(logMedStocksReturns)[1]-1),]
verdiTickerList <- c("AKVA.OL", "AMSC.OL", "HLNG.OL", "NRS.OL", "SBO.OL", "SUBC.OL", "XXL.OL")
for (i in 1:length(verdiTickerList)) {
stockTicker <- verdiTickerList[i]
stockSymbol <- getSymbols(stockTicker, src="yahoo", auto.assign=FALSE, from=dates[1], to=dates[2])
if (i == 1) {
logVerdiReturns <- cbind(log(as.numeric(stockSymbol[,4])))
} else {
logVerdiReturns <- cbind(logVerdiReturns, cbind(log(as.numeric(stockSymbol[,4]))))
}
}
logVerdiReturns <- logVerdiReturns[2:dim(logVerdiReturns)[1],]-
logVerdiReturns[1:(dim(logVerdiReturns)[1]-1),]
logAllReturns <- cbind(logVerdiReturns, logMedStocksReturns)
allTickerList <- c(verdiTickerList, medStockTickerList)
allTickerLogCorrelations <- cor(logAllReturns)
rownames(allTickerLogCorrelations) <- allTickerList
colnames(allTickerLogCorrelations) <- allTickerList
### MAKE CORRELATION PLOTS
png(file = paste(getwd(), "/correlations/allCorrplot.png", sep=""))
corrplot(allTickerLogCorrelations, method="number")
dev.off()
png(file = paste(getwd(), "/correlations/allCorrplotMixed.png", sep=""))
corrplot.mixed(allTickerLogCorrelations)
dev.off()
# Total portfolio
verdiStockWeights <- c(0.137, 0.145, 0.140, 0.150, 0.142, 0.119, 0.168)
logTotalVerdiReturns <- logVerdiReturns %*% t(t(verdiStockWeights))
totalVerdiMedLogCorrelations <- cor(cbind(logTotalVerdiReturns, logMedStocksReturns))
totalVerdiMedTickerList <- c("Verdi", medStockTickerList)
rownames(totalVerdiMedLogCorrelations) <- totalVerdiMedTickerList
colnames(totalVerdiMedLogCorrelations) <- totalVerdiMedTickerList
logTotalReturns <- cbind(logTotalVerdiReturns, logMedStocksReturns)
logTotalReturns
logTotalReturns <- cbind(logTotalVerdiReturns, logAllReturns)
dim(logTotalReturns)
apply(logTotalReturns, 2, runSD, n=20)
dim(logTotalReturns)
plot(logTotalReturns)
ts.plot(logTotalReturns)
ts.plot(logTotalReturns[,2])
logTotalVol <- exp(logTotalReturns)*sqrt(252)
logTotalVol
logTotalVol <- apply(logTotalReturns, 2, runSD, n=20)*sqrt(252)
logTotalVol
logTotalReturns
logTotalReturns <- cbind(logTotalVerdiReturns, logAllReturns)
logReturns <- logTotalReturns
logTotalVol <- apply(logTotalReturns, 2, runSD, n=20)*sqrt(252)
logReturns
logTotalReturns <- cbind(logTotalVerdiReturns, logAllReturns)
logReturns <- logTotalReturns
logTotalVol <- apply(logTotalReturns, 2, runSD, n=20)*sqrt(252)
logTotalVol <- (logTotalReturns*sqrt(252))
logTotalReturns
logTotalVol
1/logTotalReturns
ts.plot(logTotalReturns[,1])
ts.plot(logTotalReturns[,1]*sqrt(252))
logTotalReturns
ts.plot(logTotalReturns[,1]*sqrt(252))
logTotalReturns
ts.plot(logTotalReturns[,1]*sqrt(252))
ts.plot(logTotalVol[,1]*sqrt(252))
logTotalVol
logTotalReturns <- cbind(logTotalVerdiReturns, logAllReturns)
logReturns <- logTotalReturns
logTotalVol <- apply(logTotalReturns, 2, runSD, n=20)*sqrt(252)
logTotalVol <- (logTotalReturns*sqrt(252))
ts.plot(logTotalVol[,1])
logTotalVol
df
setwd("/Users/Kristian/Kristian/Dropbox/Studier/8. semester/TIO4317 Empirisk finans/Assignments/Assignment 6")
library("Rsolnp")
library("lpSolve")
# Load the data set of stock and bond indices
df <- read.table("StocksBonds.csv", header=TRUE, sep=",")
df
df[1:10,]
df <- df[1:10,]
df <- df[1:10,]
L <- dim(df)[1]       # Number of scenarios
# Vector of two index assets
indexNames <- colnames(df)
A <- cbind(df[,1], df[,2], df[,8])
colnames(A) <- c(indexNames[1], indexNames[2], indexNames[8])
P <- A
# Lambda linspace, [0,1]
Lambda <- seq(0,1, length = 100)
# Alpha level VaR
alpha <- 0.95
# Set up the initial decision variable vector
objective.in <- t(t(c(1000, rep(1, L))))
binary.vec <- t(seq(2,(L+1)))
# Set up the coefficient matrix
const.mat <- t(c(0, rep(1/L, L)))
for (l in 1:L) {
constrVec <- t(c(1, rep(0, L)))
constrVec[l+1] <- -M
const.mat <- rbind(const.mat, constrVec)
}
# Setting up the equality vector
const.dir <- t(rep(">=", (L+1)))
# Calculating V_0
V_0 <- P[1,2]*0.5 + P[1,3]*0.5
# Calculating the correct M
M <- V_0 + sum(apply(P, 2, max)[2:3])
# Optimization loop for every lambda
library("Rsolnp")
library("lpSolve")
# Load the data set of stock and bond indices
df <- read.table("StocksBonds.csv", header=TRUE, sep=",")
### Variables and parameters
n <- dim(df)[2]-1     # Number of unique stock/bond indices
df <- df[1:10,]
L <- dim(df)[1]       # Number of scenarios
# Vector of two index assets
indexNames <- colnames(df)
A <- cbind(df[,1], df[,2], df[,8])
colnames(A) <- c(indexNames[1], indexNames[2], indexNames[8])
P <- A
# Lambda linspace, [0,1]
Lambda <- seq(0,1, length = 100)
# Alpha level VaR
alpha <- 0.95
# Set up the initial decision variable vector
objective.in <- t(t(c(1000, rep(1, L))))
binary.vec <- t(seq(2,(L+1)))
# Calculating V_0
V_0 <- P[1,2]*0.5 + P[1,3]*0.5
# Calculating the correct M
M <- V_0 + sum(apply(P, 2, max)[2:3])
# Set up the coefficient matrix
const.mat <- t(c(0, rep(1/L, L)))
for (l in 1:L) {
constrVec <- t(c(1, rep(0, L)))
constrVec[l+1] <- -M
const.mat <- rbind(const.mat, constrVec)
}
# Setting up the equality vector
const.dir <- t(rep(">=", (L+1)))
# Optimization loop for every lambda
zeta <- t(rep(0, (L+1)))
M
for (i in 1:length(Lambda)) {
lambda <- Lambda[i]
# Set up the constant RHS
const.rhs <- t(alpha)
for (l in 1:L) {
const.rhs <- rbind(const.rhs, t(V_0 - M
- lambda*P[l,2] - (1-lambda)*P[l,3]))
}
lp(direction = "min", objective.in = objective.in, const.mat = const.mat,
const.dir = const.dir, const.rhs = const.rhs, binary.vec = binary.vec)
}
lp
lp(direction = "min", objective.in = objective.in, const.mat = const.mat,
const.dir = const.dir, const.rhs = const.rhs, binary.vec = binary.vec)
get.objective(lp)
lp
lp$solution
for (i in 1:length(Lambda)) {
lambda <- Lambda[i]
# Set up the constant RHS
const.rhs <- t(alpha)
for (l in 1:L) {
const.rhs <- rbind(const.rhs, t(V_0 - M
- lambda*P[l,2] - (1-lambda)*P[l,3]))
}
a <- lp(direction = "min", objective.in = objective.in, const.mat = const.mat,
const.dir = const.dir, const.rhs = const.rhs, binary.vec = binary.vec)$solution
}
a
library("Rsolnp")
library("lpSolve")
# Load the data set of stock and bond indices
df <- read.table("StocksBonds.csv", header=TRUE, sep=",")
### Variables and parameters
n <- dim(df)[2]-1     # Number of unique stock/bond indices
df <- df[1:10,]
L <- dim(df)[1]       # Number of scenarios
# Vector of two index assets
indexNames <- colnames(df)
A <- cbind(df[,1], df[,2], df[,8])
colnames(A) <- c(indexNames[1], indexNames[2], indexNames[8])
P <- A
# Lambda linspace, [0,1]
Lambda <- seq(0,1, length = 100)
# Alpha level VaR
alpha <- 0.95
# Set up the initial decision variable vector
objective.in <- t(t(c(1, rep(0, L))))
binary.vec <- t(seq(2,(L+1)))
# Calculating V_0
V_0 <- P[1,2]*0.5 + P[1,3]*0.5
# Calculating the correct M
M <- V_0 + sum(apply(P, 2, max)[2:3])
# Set up the coefficient matrix
const.mat <- t(c(0, rep(1/L, L)))
for (l in 1:L) {
constrVec <- t(c(1, rep(0, L)))
constrVec[l+1] <- -M
const.mat <- rbind(const.mat, constrVec)
}
# Setting up the equality vector
const.dir <- t(rep(">=", (L+1)))
# Optimization loop for every lambda
zeta <- t(rep(0, (L+1)))
for (i in 1:length(Lambda)) {
lambda <- Lambda[i]
# Set up the constant RHS
const.rhs <- t(alpha)
for (l in 1:L) {
const.rhs <- rbind(const.rhs, t(V_0 - M
- lambda*P[l,2] - (1-lambda)*P[l,3]))
}
a <- lp(direction = "min", objective.in = objective.in, const.mat = const.mat,
const.dir = const.dir, const.rhs = const.rhs, binary.vec = binary.vec)$solution
}
a
objective.in
lambda
lambda = 0.5
# Set up the constant RHS
const.rhs <- t(alpha)
for (l in 1:L) {
const.rhs <- rbind(const.rhs, t(V_0 - M
- lambda*P[l,2] - (1-lambda)*P[l,3]))
}
a <- lp(direction = "min", objective.in = objective.in, const.mat = const.mat,
const.dir = const.dir, const.rhs = const.rhs, binary.vec = binary.vec)$solution
a
a[1]
Zeta <- t(rep(0, length(Lambda))
for (i in 1:length(Lambda)) {
lambda <- Lambda[i]
# Set up the constant RHS
const.rhs <- t(alpha)
for (l in 1:L) {
const.rhs <- rbind(const.rhs, t(V_0 - M
- lambda*P[l,2] - (1-lambda)*P[l,3]))
}
zeta <- lp(direction = "min", objective.in = objective.in, const.mat = const.mat,
const.dir = const.dir, const.rhs = const.rhs, binary.vec = binary.vec)$solution[1]
Zeta[i] <- zeta
}
Zeta <- t(rep(0, length(Lambda)))
for (i in 1:length(Lambda)) {
lambda <- Lambda[i]
# Set up the constant RHS
const.rhs <- t(alpha)
for (l in 1:L) {
const.rhs <- rbind(const.rhs, t(V_0 - M
- lambda*P[l,2] - (1-lambda)*P[l,3]))
}
zeta <- lp(direction = "min", objective.in = objective.in, const.mat = const.mat,
const.dir = const.dir, const.rhs = const.rhs, binary.vec = binary.vec)$solution[1]
Zeta[i] <- zeta
}
Zeta
ts.plot(Zeta)
plot(Zeta ~ Lambda)
length(Zeta)
length(Lambda)
Zeta
c(Zeta)
Lambda
plot(c(Zeta) ~ c(Lambda))
plot(c(Zeta) ~ c(Lambda), type="l")
plot(c(Zeta) ~ c(Lambda), type = "l")
library("Rsolnp")
library("lpSolve")
# Load the data set of stock and bond indices
df <- read.table("StocksBonds.csv", header=TRUE, sep=",")
### Variables and parameters
n <- dim(df)[2]-1     # Number of unique stock/bond indices
df <- df[1:100,]
L <- dim(df)[1]       # Number of scenarios
# Vector of two index assets
indexNames <- colnames(df)
A <- cbind(df[,1], df[,2], df[,8])
colnames(A) <- c(indexNames[1], indexNames[2], indexNames[8])
P <- A
# Lambda linspace, [0,1]
Lambda <- seq(0,1, length = 100)
# Alpha level VaR
alpha <- 0.95
# Set up the initial decision variable vector
objective.in <- t(t(c(1, rep(0, L))))
binary.vec <- t(seq(2,(L+1)))
# Calculating V_0
V_0 <- P[1,2]*0.5 + P[1,3]*0.5
# Calculating the correct M
M <- V_0 + sum(apply(P, 2, max)[2:3])
# Set up the coefficient matrix
const.mat <- t(c(0, rep(1/L, L)))
for (l in 1:L) {
constrVec <- t(c(1, rep(0, L)))
constrVec[l+1] <- -M
const.mat <- rbind(const.mat, constrVec)
}
# Setting up the equality vector
const.dir <- t(rep(">=", (L+1)))
# Optimization loop for every lambda
Zeta <- t(rep(0, length(Lambda)))
for (i in 1:length(Lambda)) {
lambda <- Lambda[i]
# Set up the constant RHS
const.rhs <- t(alpha)
for (l in 1:L) {
const.rhs <- rbind(const.rhs, t(V_0 - M
- lambda*P[l,2] - (1-lambda)*P[l,3]))
}
zeta <- lp(direction = "min", objective.in = objective.in, const.mat = const.mat,
const.dir = const.dir, const.rhs = const.rhs, binary.vec = binary.vec)$solution[1]
Zeta[i] <- zeta
}
plot(c(Zeta) ~ c(Lambda), type = "l")
Zeta
library("Rsolnp")
library("lpSolve")
# Load the data set of stock and bond indices
df <- read.table("StocksBonds.csv", header=TRUE, sep=",")
### Variables and parameters
n <- dim(df)[2]-1     # Number of unique stock/bond indices
df <- df[1:500,]
L <- dim(df)[1]       # Number of scenarios
# Vector of two index assets
indexNames <- colnames(df)
A <- cbind(df[,1], df[,2], df[,8])
colnames(A) <- c(indexNames[1], indexNames[2], indexNames[8])
P <- A
# Lambda linspace, [0,1]
Lambda <- seq(0,1, length = 100)
# Alpha level VaR
alpha <- 0.95
# Set up the initial decision variable vector
objective.in <- t(t(c(1, rep(0, L))))
binary.vec <- t(seq(2,(L+1)))
# Calculating V_0
V_0 <- P[1,2]*0.5 + P[1,3]*0.5
# Calculating the correct M
M <- V_0 + sum(apply(P, 2, max)[2:3])
# Set up the coefficient matrix
const.mat <- t(c(0, rep(1/L, L)))
for (l in 1:L) {
constrVec <- t(c(1, rep(0, L)))
constrVec[l+1] <- -M
const.mat <- rbind(const.mat, constrVec)
}
# Setting up the equality vector
const.dir <- t(rep(">=", (L+1)))
# Optimization loop for every lambda
Zeta <- t(rep(0, length(Lambda)))
for (i in 1:length(Lambda)) {
lambda <- Lambda[i]
# Set up the constant RHS
const.rhs <- t(alpha)
for (l in 1:L) {
const.rhs <- rbind(const.rhs, t(V_0 - M
- lambda*P[l,2] - (1-lambda)*P[l,3]))
}
zeta <- lp(direction = "min", objective.in = objective.in, const.mat = const.mat,
const.dir = const.dir, const.rhs = const.rhs, binary.vec = binary.vec)$solution[1]
Zeta[i] <- zeta
}
plot(c(Zeta) ~ c(Lambda), type = "l")
